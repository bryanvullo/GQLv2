The Input and Output Format
For each problem we will declare the name of one input le in a simple Graph Data format. The particular variant of Graph Data we will be using is a simplified version of the input for mat for Neo4j (see https://neo4j.com/docs/operations-manual/current/tools/neo4j-admin/neo4jadmin-import/#import-tool-header-format). A key design point of the Neo4j Graph Data model is that both the nodes of the graph and the edges between nodes (relationships) may contain both typed property data and labelling information.

The input le name will correspond to a le in the current working directory with an extension .n4j . For example, if the problem input le is called foo and your interpreter is executed in directory C:/Home/Users/jr/STQL/ then the input will be at C:/Home/Users/jr/STQL/foo.n4j . The input les will be in a simple Neo4j format as follows: The overriding data format is that of Comma Separated Value (CSV). That is, each input le will contain a number of rows with comma separated elds. Input les contain a number nodes sets followed by collections of relationships between these nodes. Each node set begins with a node header row that describes the property eld names and types for that node set. Then follows all of the entries for that node set, one per row. Similarly, a relationship begins with relationship header row that also describes the property eld names and types for the relationship. A node header row must be of the form (using regular expression syntax):

:ID (,<name> : <Type>)* (,:LABEL)?

that is, we must declare an ID eld. We have zero or more named typed eld declarations representing property values of the node. Finally, we have an optional keyword :LABEL that allows us to tag nodes with a label list. We separate multiple labels with semi-colon. Subsequent entries in the input le following a node header must match the format of the previous header row. For example,

:ID, colour:string, age : integer , active : boolean , :LABEL
vehicle1 , "Yellow", 3, true , Car
vehicle2 , "Blue" , 7, true , Car
vehicle3 , "Red" , 11, false , Car
vehicle4 , null, 2, null, Car;Imported

The ID values must use alphanumeric characters only. The eld names, that is the <name> entries, must be alpha-numeric only. Types can be one of string, integer, or boolean only. Fields must be monomorphic in that, if a eld name is used multiple times across the document then it must be given the same type in each case. Labels must be alphabetic characters only. The literal values range over string values that are delimited by quotes and contain only alphabetic characters, integer values that match the regexp [+-]?[0-9]+ and boolean values true and false. The value null is also a valid value of any type. There may be multiple such node sets in the input le. Please note that Identi er values for the nodes must be unique across the input le. An input le that has two node rows beginning with the same ID value is considered an error, even if it is a duplicate row. Following the node sets, we have a number of relationship sets. A relationship header row must be of the form:

:START_ID (, <name> : <Type>)* , :END_ID , :TYPE

that is, we state that this is a relationship between a source node with a given start ID and a target node with a given end ID. There are zero or more property elds associated with the relationship and a relationship has exactly one TYPE. Like labels, the TYPE values describe the nature of the relationship and must be alphabetic characters only. Unlike labels, we only ever have a single TYPE. Subsequent entries in the input le following a relationship header must match the format of the previous header row. For example,

:START_ID, speed : integer , :END_ID, :TYPE
vehicle2 , 30, vehicle3, CrashedInto
vehicle2 , 20 , vehicle1, CrashedInto
vehicle4 , 15, vehicle2, CrashedInto

describes three relationships (edges in the graph). Two of the relationships have a source node vehicle2 with targets vehicle3 and vehicle1. The third relationship has source node vehicle4 and target vehicle2. We use the shorthand e.g. vehicle4-CrashedInto->vehicle2 to describe the presence of an edge. There may be multiple such relationship sets in the input le. Spaces are allowed between data-items in each row and blank rows in the input le are permitted and may be skipped over. You may assume in the stated problems that all input les will be well-formed in this simple Neo4j input format. The order in which entries in a node set appear is unimportant. The order in which node sets appear is unimportant. The order in which the typed property data on nodes and relationships is unimportant and nally, the order in which labels appear is unimportant. For each stated problem, the output should also be in the same simple Neo4j format. I will compare your outputs against expected outputs by parsing the output as a graph and use a graph comparison function. The output should always be printed to Standard Out.

Problems
For every problem below, you may assume that we will place a simple Neo4j le in the same directory where we execute your interpreter. The le will always be compatible with the simple Neo4j format. You may assume that we will not require you to perform any additional operations on the literal values other than those indicated by the problems given below. For each problem I will provide one example input le and the expected output for that input. These are listed in the Appendix but will also be available as a zip le from the module website. We will test your solutions on input les di erent to these but all inputs used will satisfy the input format above.

Problem 1- Simple Node Query
Given an input le named access.n4j , representing personnel and guests with access to a building, output a graph that contains all of the nodes in the input graph that have label Visitor along with all nodes whose value for eld age is less than or equal to 25. The output should be in graph format as above given as a single node set only. The header row need only contain the ID eld, the single age property and the label. You should use null values for nodes with no age value.

Problem 2- Simple Relationship Query
Given an input le named tasks.n4j , representing the tasks on a construction job, output a graph that contains the whole of the input graph along with some additional relationship edges as follows. For all nodes nT that are the target of some relationship that has a eld named priority with value greater than or equal to 8 and for all nodes labelled Sta nS that are the source of some relationship that has a eld value named available with value true, include the extra relationship nS-PossiblyAllocated-> nT in the output graph.

Problem 3- Parametric Queries
Given an input le named table.n4j representing a graph of sports teams that contains data for the seasons results, nd a list of teams that are on the same points as a team that drew with another team that the rst team lost to. That is, nd a set of nodes n such that n-Beat->n for some source n say. For each such n, and all nodes n such that either n-DrewWith-> n-Beat-> n, or n-DrewWith-> n and n-Beat-> n for some n. Return as output a graph consisting of nodes n whose eld value named points is non-null and equal to the eld value named points of n . Your output graph can be returned as a single node set with header row just the node ID and the property eld points.

Problem 4- Graph Filtering
Given a le named network.n4j representing a graph of persons, their friendships and employers, and all persons with rst names beginning with A, B , or C , (as nodes) who have friends older than themselves that dont work in a cafe. The employer nodes are labelled according to their type of business and all persons have a rstName and age elds. There are two relationship sets with types IsFriend and WorksFor . The IsFriend relationship is not necessarily symmetric. You should return the subgraph of the input graph containg all person nodes that have first names beginning with A, B , or C and older friends that dont work in a cafe along with all of these friend nodes. Do not include the friends that work in a cafe. You should return the IsFriend relationship set between the remaining nodes in the subgraph also.

Problem 5- Field Updates
Given a led named loyalty.n4j containing a graph of customers of a number of businesses operating a joint loyalty scheme, and all persons who are customers of any business who recommended another customer of that same business. There are person and business node sets and there are two relationship sets with labels Recommended and CustomerOf . The CustomerOf relationship have a property eld named reward and the business nodes have a property eld named bonus . You should output an modi ed graph as follows. Output an updated graph in which for all persons p such that p-CustomerOf-> b for some b and p-Recommended-> q-CustomerOf-> b for some q, we have updated both the reward eld of p-CustomerOf-> b and q-CustomerOf-> b by incrementing them both by the value of the bonus eld of the business node b. You should also remove the entire relationship set for Recommended.

Interpreter Spec
Your interpreter is to take a le name (the program in your language) as a single command line argument. The interpreter should produce output on standard output (stdout) and error messages on standard error (stderr). For each problem, we will test whether your code performs correctly by using a number of tests. We only care about correctness and performance will not be assessed (within reason- our marking scripts will timeout after a generous period of time). You can assume that for the tests we will use correctly formatted input. For example, when assessing your solution for Problem 1 we will run

./Gql pr1.gql

in a directory where we also provide our own versions of graph.n4j. We will then compare the contents of stdout against our expected outputs. Whitespace and formatting is unimportant as long as the output is adheres to the prescribed simple Neo4j output format and contains no other text. We will parse your outputs and compare them against expected outputs as Graphs. For that reason, order of entries in the output le does not matter

// pr1.gql
DataStructure access = ACCESS("./access.n4j");

access = access.CASE (
    (dataPoint.HAS("LABEL") AND dataPoint.:LABEL i== "Visitor") OR
    (dataPoint.HAS("age") AND dataPoint.age <= 25)
);

STDOUT (access);

// pr2.gql
DataStructure tasks = ACCESS("./tasks.n4j");
DataStructure tasksCopy = tasks;

tasks = tasks.CASE (
    dataPoint.HAS("priority") AND dataPoint.priority >= 8
);

THROUGH (DataPoint highPriorityTask : tasks) {
    THROUGH (DataPoint availableTask : tasks) {
        CONDIF (availableTask.HAS("available") AND availableTask.available i== True) {
            Association possiblyAllocated;
            possiblyAllocated.:CLASS = "PossiblyAllocated";
            possiblyAllocated.:START_ID = availableTask;
            possiblyAllocated.:END_ID = highPriorityTask;
            tasksCopy.PLUS(possiblyAllocated);
        }
    }
}

STDOUT (tasksCopy);

// pr3.gql
DataStructure table = ACCESS("./table.n4j");
DataStructure output;

THROUGH (DataPoint team : table) {
    CONDIF (team.HAS("points") AND team.points !== null) {
        THROUGH (DataPoint drawnTeam : table) {
            CONDIF (drawnTeam.HAS("points") AND drawnTeam.points i== team.points) {
                THROUGH (DataPoint beatenTeam : table) {
                    CONDIF (
                        (drawnTeam -[:CLASS i== "DrewWith"]>> beatenTeam AND team -[:CLASS i== "Beat"]>> beatenTeam) OR
                        (beatenTeam -[:CLASS i== "DrewWith"]>> drawnTeam AND team -[:CLASS i== "Beat"]>> beatenTeam)
                    ) {
                        output.PLUS(team);
                    }
                }
            }
        }
    }
}

STDOUT(output);

// pr4.gql
DataStructure network = ACCESS("./network.n4j");
DataStructure output;

THROUGH (DataPoint person : network) {
    CONDIF (
        person.HAS("firstName") AND
        (
            person.firstName >= "A" AND person.firstName <= "C"
        )
    ) {
        output.PLUS(person);
        
        THROUGH (DataPoint friend : person.CALLASSOCIATION(association -[:TYPE i== "IsFriend"]>> dataPoint)) {
            CONDIF (
                friend.HAS("age") AND
                person.HAS("age") AND
                friend.age > person.age
            ) {
                DataStructure friendEmployers = friend.CALLASSOCIATION(association -[:TYPE i== "WorksFor"]>> dataPoint);
                Bool friendWorksInCafe = False;
                
                THROUGH (DataPoint employer : friendEmployers) {
                    CONDIF (employer.HAS("LABEL") AND employer.:LABEL i== "Cafe") {
                        friendWorksInCafe = True;
                    }
                }
                
                CONDIF (friendWorksInCafe i== False) {
                    output.PLUS(friend);
                    output.PLUS(person -[association.:TYPE i== "IsFriend"]>> friend);
                }
            }
        }
    }
}

STDOUT(output);

// pr5.gql
DataStructure loyalty = ACCESS("./loyalty.n4j");
DataStructure output = loyalty;

THROUGH (DataPoint p : loyalty) {
    THROUGH (DataPoint b : p.CALLDATAPOINT(dataPoint -[association.:CLASS i== "CustomerOf"]>> anyNode)) {
        DataStructure recommendedCustomers = p.CALLDATAPOINT(dataPoint -[association.:CLASS i== "Recommended"]>> anyNode);
        THROUGH (DataPoint q : recommendedCustomers.CALLDATAPOINT(dataPoint -[association.:CLASS i== "CustomerOf"]>> b)) {
            DataStructure pCustomerOf = p.CALLASSOCIATION(association -[:CLASS i== "CustomerOf"]>> b);
            DataStructure qCustomerOf = q.CALLASSOCIATION(association -[:CLASS i== "CustomerOf"]>> b);
            
            pCustomerOf.reward =+ b.bonus;
            qCustomerOf.reward =+ b.bonus;
        }
    }
}

output = output.CALLASSOCIATION(association -[:CLASS !== "Recommended"]>> dataPoint);

STDOUT (output);

// Terminal output for problems

Start Testing PR1
[
X (ClassFinalSet Graph "access" (ACCESS "./access.n4j")),
X (Set (Identifier "access") (CASEQ (Identifier "access") (LogicalOr (LogicalAnd (Has (Identifier "dataPoint") ["LABEL"]) (Identical (CallAttribute (Identifier "dataPoint") "LABEL") (Chars "Visitor"))) (LogicalAnd (Has (Identifier "dataPoint") ["age"]) (InequalitySlackLesser (CallAttribute (Identifier "dataPoint") "age") (NumericXX (NumericTerminal 25))))))),
X (STDOUT "access")
]

End Testing PR1

Start Testing PR2

[
X (ClassFinalSet Graph "tasks" (ACCESS "./tasks.n4j")),
X (ClassFinalSet Graph "tasksCopy" (Identifier "tasks")),
X (Set (Identifier "tasks") (CASEQ (Identifier "tasks") (LogicalAnd (Has (Identifier "dataPoint") ["priority"]) (InequalitySlackGreater (CallAttribute (Identifier "dataPoint") "priority") (NumericXX (NumericTerminal 8)))))),
THROUGHQ Node "highPriorityTask" (Identifier "tasks") [THROUGHQ Node "availableTask" (Identifier "tasks") [CONDIFQ (LogicalAnd (Has (Identifier "availableTask") ["available"]) (Identical (CallAttribute (Identifier "availableTask") "available") (BoolXX (BoolTerminal True)))) [X (ClassShow Edge "possiblyAllocated"),
X (Set (CallAttribute (Identifier "possiblyAllocated") "CLASS") (Chars "PossiblyAllocated")),
X (Set (CallAttribute (Identifier "possiblyAllocated") "START_ID") (Identifier "availableTask")),
X (Set (CallAttribute (Identifier "possiblyAllocated") "END_ID") (Identifier "highPriorityTask")),
X (PlusQ (Identifier "tasksCopy") (Identifier "possiblyAllocated"))]]],
X (STDOUT "tasksCopy")
]

End Testing PR2

Start Testing PR3

[
X (ClassFinalSet Graph "table" (ACCESS "./table.n4j")),
X (ClassShow Graph "output"),
THROUGHQ Node "team" (Identifier "table") [CONDIFQ (LogicalAnd (Has (Identifier "team") ["points"]) (IdenticalNot (CallAttribute (Identifier "team") "points") (Identifier "null"))) [THROUGHQ Node "drawnTeam" (Identifier "table") [CONDIFQ (LogicalAnd (Has (Identifier "drawnTeam") ["points"]) (Identical (CallAttribute (Identifier "drawnTeam") "points") (CallAttribute (Identifier "team") "points"))) [THROUGHQ Node "beatenTeam" (Identifier "table") [CONDIFQ (LogicalOr (LogicalAnd (AssociationQ "drawnTeam" (Identical (Identifier "CLASS") (Chars "DrewWith")) "beatenTeam") (AssociationQ "team" (Identical (Identifier "CLASS") (Chars "Beat")) "beatenTeam")) (LogicalAnd (AssociationQ "beatenTeam" (Identical (Identifier "CLASS") (Chars "DrewWith")) "drawnTeam") (AssociationQ "team" (Identical (Identifier "CLASS") (Chars "Beat")) "beatenTeam"))) [X (PlusQ (Identifier "output") (Identifier "team"))]]]]]],
X (STDOUT "output")
]

End Testing PR3

Start Testing PR4

[
X (ClassFinalSet Graph "network" (ACCESS "./network.n4j")),
X (ClassShow Graph "output"),
THROUGHQ Node "person" (Identifier "network") [CONDIFQ (LogicalAnd (Has (Identifier "person") ["firstName"]) (LogicalAnd (InequalitySlackGreater (CallAttribute (Identifier "person") "firstName") (Chars "A")) (InequalitySlackLesser (CallAttribute (Identifier "person") "firstName") (Chars "C")))) [X (PlusQ (Identifier "output") (Identifier "person")),
THROUGHQ Node "friend" (CallAssociation (Identifier "person") (AssociationQ "association" (Identical (Identifier "TYPE") (Chars "IsFriend")) "dataPoint")) [CONDIFQ (LogicalAnd (Has (Identifier "friend") ["age"]) (LogicalAnd (Has (Identifier "person") ["age"]) (InequalityStrictGreater (CallAttribute (Identifier "friend") "age") (CallAttribute (Identifier "person") "age")))) [X (ClassFinalSet Graph "friendEmployers" (CallAssociation (Identifier "friend") (AssociationQ "association" (Identical (Identifier "TYPE") (Chars "WorksFor")) "dataPoint"))),
X (ClassFinalSet Bool "friendWorksInCafe" (BoolXX (BoolTerminal False))),
THROUGHQ Node "employer" (Identifier "friendEmployers") [CONDIFQ (LogicalAnd (Has (Identifier "employer") ["LABEL"]) (Identical (CallAttribute (Identifier "employer") "LABEL") (Chars "Cafe"))) [X (Set (Identifier "friendWorksInCafe") (BoolXX (BoolTerminal True)))]],
CONDIFQ (Identical (Identifier "friendWorksInCafe") (BoolXX (BoolTerminal False))) [X (PlusQ (Identifier "output") (Identifier "friend")),
X (PlusQ (Identifier "output") (BoolXX (AssociationQ "person" (Identical (CallAttribute (Identifier "association") "TYPE") (Chars "IsFriend")) "friend")))]]]]],
X (STDOUT "output")
]

End Testing PR4

Start Testing PR5

[
X (ClassFinalSet Graph "loyalty" (ACCESS "./loyalty.n4j")),
X (ClassFinalSet Graph "output" (Identifier "loyalty")),
THROUGHQ Node "p" (Identifier "loyalty") [THROUGHQ Node "b" (CallDataPoint (Identifier "p") (BoolXX (AssociationQ "dataPoint" (Identical (CallAttribute (Identifier "association") "CLASS") (Chars "CustomerOf")) "anyNode"))) [X (ClassFinalSet Graph "recommendedCustomers" (CallDataPoint (Identifier "p") (BoolXX (AssociationQ "dataPoint" (Identical (CallAttribute (Identifier "association") "CLASS") (Chars "Recommended")) "anyNode")))),
THROUGHQ Node "q" (CallDataPoint (Identifier "recommendedCustomers") (BoolXX (AssociationQ "dataPoint" (Identical (CallAttribute (Identifier "association") "CLASS") (Chars "CustomerOf")) "b"))) [X (ClassFinalSet Graph "pCustomerOf" (CallAssociation (Identifier "p") (AssociationQ "association" (Identical (Identifier "CLASS") (Chars "CustomerOf")) "b"))),
X (ClassFinalSet Graph "qCustomerOf" (CallAssociation (Identifier "q") (AssociationQ "association" (Identical (Identifier "CLASS") (Chars "CustomerOf")) "b"))),
X (NumericIncrease (CallAttribute (Identifier "pCustomerOf") "reward") (CallAttribute (Identifier "b") "bonus")),
X (NumericIncrease (CallAttribute (Identifier "qCustomerOf") "reward") (CallAttribute (Identifier "b") "bonus"))]]],
X (Set (Identifier "output") (CallAssociation (Identifier "output") (AssociationQ "association" (IdenticalNot (Identifier "CLASS") (Chars "Recommended")) "dataPoint"))),
X (STDOUT "output")
]

End Testing PR5

// GQL.HS
import System.Environment (getArgs)
import Parser
import Lexer
import InputParser (parseInput, Tables, Table, Row, ID, Labels)
import InputLexer (lexInput, Token(..))
import Interpreter (interpret)
import Printer (printOutput)

main :: IO ()
main = do
    (filename:_) <- getArgs
    contents <- readFile filename
    -- let inputResult = parseInput $ lexInput contents
    -- print inputResult
    let tokens = alexScanTokens contents
    let result = parser tokens
    print result 
    
    -- interpret the query
    -- let output = interpret result
    -- print output

    -- after we interpret we print the output
    -- let result = parseInput $ lexInput contents
    -- printOutput result